Jetpack 강의를 들으면서 코루틴에 대해 간단히 배웠는데 잘 이해가 되지 않아 다시 한번 공부하면서 정리하려고 한다.

## 1. 코루틴이란?

안드로이드에서는 기존 AsyncTask를 이용해서 손쉽게 비동기 프로그래밍을 구현했었다.
AsyncTask는 비동기 작업을 백그라운드 스레드에서 실행하고 결과가 UI 스레드에 게시되게 하는 데 사용되는 클래스이다.
그러나 메모리 누수 등 여러가지 문제로 API 30 부터는 deprecate 시키고 코루틴을 사용하도록 권장하고 있다.
코루틴을 이용하면 메모리를 효율적으로 사용하면서 손쉽게 비동기 처리를 할 수 있다.

코루틴을 사용하면 여러 함수들이 번갈아가면서 실행되어 스레드의 중단없이 비동기적인 프로그래밍이 가능하다.
즉, 코루틴을 사용하면 루틴이 실행되었더라도 더 바쁜 다른 루틴이 실행되는 동안 잠시 멈췄다가, 바쁜게 끝나면 재시작하여 나머지 작업을 끝내는 형태의 비동기 프로그래밍이 가능하게 된다.
또 코루틴은 자기 스스로가 메인 루틴이 되면서도 서브 루틴이 될 수 있다는 특징도 있다.

코루틴은 스레드 위에서 실행되는데 여러가지 코루틴이 존재할 수 있다. 코루틴 1을 실행하던 중 2가 실행되면 스레드를 정지시키고 다른 스레드로 전환되는 것이 아니라 기존 스레드를 유지하며 기존 스레드에서 코루틴2를 실행하게 된다.
이후 코루틴 1을 다시 실행할 때, 저장해 둔 코루틴 1 상태를 불러와 다시 스레드에서 코루틴 1을 실행하게 된다.
한마디로 스레드의 멈춤없이 루틴을 돌릴 수 있게 되며, 이는 성능 향상을 기대할 수 있고 여러 스레드를 사용하는 것보다 훨씬 적은 자원 소모를 하게된다.

## 2. 코루틴과 스레드

구글에서는 AsyncTask를 코루틴으로 대체하여 쓰라고 하고 있기 때문에 얼핏 생각하면 코루틴은 AsyncTask의 약점인 메모리누수가 없는 스레드라고 생각하기 쉽다.
그러나 코루틴은 스레드가 아니다.

### 메모리 구조의 차이

프로세스에서 실행되는 독립된 여러 흐름중의 하나를 스레드라고 한다. 프로세스는 자기가 사용할 메모리영역(Heap)을 할당받는데, 이때 스레드는 Heap안에서 다시 자신만이 사용할 수 있는 고유의 메모리 영역(Stack)을 할당받게 된다.

그런데 코루틴은 스택을 할당받지 않고 프로세스의 Heap 메모리를 공유하여 사용하기 때문에 비동기 작업을 구현한다는 점에서는 스레드와 동일한 일을 하고 있지만, 스레드보다는 함수에 가까운 구조를 가지고 있다.

### 수행방식의 차이

코루틴은 비선점형 멀티태스킹이고 스레드는 선점형 멀티태스킹이다.
스레드는 실제로 멀티코어를 사용함으로써 동시에 복수의 스레드를 처리할 수 있는데 이것을 병행성이 있다고 한다.
그런데 코루틴은 CPU를 시간분할하여 사용하기 때문에 실제로는 복수의 작업을 동시에 처리할 수 없어 병행성은 없다. 하지만 코루틴은 한번에 한개밖에 실행되지 않음에도 불구하고 전환속도가 빠르기 때문에 외부에서 볼 때는 마치 동시에 처리되는 것처럼 인식되므로 동시성이 있다고 한다.

### 코루틴의 장점

예를들어 세개의 스레드를 사용해야 하는 작업을 코루틴 세개로 만들어 사용할 경우 스택을 따로 할당할 필요가 없으니 사용되는 메모리가 줄어들게 된다. 그리고 스레드끼리 처리순서를 조정할 때 메모리를 공유하지 않기 때문에 수행해야 했던 context switching을 하지 않게 되므로 작업전환시의 오버헤드도 줄어들게 된다. 한 개의 스레드 안에서 여러개의 코루틴이 돌아가도록 할 수 있으니 스레드를 불필요하게 많이 만들어야 할 필요도 없어지게 된다.

### 코틀린에서의 사용

코틀린의 코루틴 안에서 실행되는 함수에는 suspend 키워드를 붙여서 실행을 보류하거나 재개할수 있다는 표시를 하게 된다.

공식 가이드에 따르면 suspend 키워드로 마킹된 함수는 Continuation Passing Style로 변환되고, Coroutine Builder를 통해 적절한 스레드 상에서 시나리오에 따라 동작하도록 구성되게 된다.

## 3. 코루틴의 흐름

출처: https://wooooooak.github.io/kotlin/2019/08/25/%EC%BD%94%ED%8B%80%EB%A6%B0-%EC%BD%94%EB%A3%A8%ED%8B%B4-%EA%B0%9C%EB%85%90-%EC%9D%B5%ED%9E%88%EA%B8%B0/
![](https://velog.velcdn.com/images/woonyumnyum/post/b48b4577-e2bb-42d5-bad0-864864ad970a/image.png)

우리가 늘 작성해왔던 코드를 보자.
여기서 main 함수가 말 그대로 main routine, sub 함수가 sub routine이다. 메인이 되는 함수는 다른 서브 함수인 plusOne을 호출한다. 그러면 메인 쓰레드가 plusOne이라는 서브 루틴에 진입한다. 그 아래 코드들을 쭉쭉 실행해서 return 문을 만나면 서브루틴을 호출했던 부분으로 탈출한다. 그리고 진입점과 탈출점 사이에 쓰레드는 블락되어있다.

![](https://velog.velcdn.com/images/woonyumnyum/post/9c259bd0-380c-471d-b3ec-32c4711c42b6/image.png)

sub routine(서브 함수)은 루틴에 진입하는 지점과 빠져나오는 지점이 명확하다. 즉, 메인 루틴이 서브루틴을 호출하면, 서브루틴의 맨 처음 부분에 진입하여 return문을 만나거나 서브루틴의 닫는 괄호를 만나면 해당 서브루틴을 빠져나오게 된다.
그러나 코루틴은 다르다.

![](https://velog.velcdn.com/images/woonyumnyum/post/04517c54-5bbe-40de-ab44-9996e41a52f5/image.png)
코루틴도 하나의 routine이기 때문에 하나의 함수로 생각하면 된다. 그런데 이 함수에 진입점도 여러개고, 함수를 빠져나갈 수 있는 탈출점도 여러개다. 즉, **코루틴 함수는 꼭 return 문이나 마지막 닫는 괄호를 만나지 않더라고 언제든지 중간에 나갈 수 있고, 언제든지 다시 나갔던 그 지점으로 들어올 수 있다.**
코드로 알아보자.

![](https://velog.velcdn.com/images/woonyumnyum/post/dd29bc3c-15df-4190-84e8-82a8feec7e4b/image.png)

(실제로 startCoroutine이라는 빌더는 존재하지 않는다. 실제 코루틴 라이브러리에는 다른방식으로 코루틴을 만들지만 여기서는 이해를 위해 쉽게 startCoroutine이라고 사용한다.)

startCoroutine이라는 코루틴을 만나게 되면 해당 함수는 코루틴으로 작동할 수 있다. 따라서 언제든 함수 실행 중간에 나갈 수도 있고, 다시 들어올 수도 있는 자격이 부여되는 것이다.
언제 코루틴을 중간에 나갈수 있을까? `suspend`로 선언된 함수를 만나면 코루틴 밖으로 잠시 나갈 수 있다.

Main 함수가 drawPerson()을 호출하면 startCoroutine 블럭을 만나 코루틴이 시작된다. 이제 drawPerson()은 진입점과 탈출점이 여러개가 되는 자격이 주어진다.
코루틴 블록 안에 suspend로 정의된 함수가 없다면 그냥 마지막 괄호를 만날 때 까지 계속 실행된다.
그러나 drawHead() 같이 `suspend` 키워드로 정의된 함수를 만나면, drawHead() 부분에서 더 이상 아래 코드를 실행하지 않고 drawPerson()이라는 코루틴 함수를 잠시 탈출한다.

그렇게 메인스레드가 코루틴 밖으로 나가서 다른 코드들을 실행하다가도(**Head는 어디선가 계속 그려지고 있다.** drawHead() 함수의 기능은 메인쓰레드에서 동시성 프로그래밍으로 작동하고 있을수도 있고, 다른 쓰레드에서 돌아가고 있을 수도 있다. 그것은 **개발자가 자유롭게 선택할 수 있다**), drawHead()가 제 역할을 끝내면 다시 아까 탈출했던 코루틴 drawPerson()으로 돌아온다. 아까 멈추어놓았던 drawHead() 아래인 drawBody()부터 재개(resume)된다.

그럼 직접 코드를 실행시켜보자.

## 4. 예제

```kotlin
fun Main {
        CoroutineScope(IO).launch { Sub() }
    }

    suspend fun Sub() {
        A()
        B()
    }

    suspend fun A() {
        delay(10000)
        Log.d("MainActivity", "A출력")
    }

    suspend fun B() {
        delay(1000)
        Log.d("MainActivity", "B출력")
    }
}
```

![](https://velog.velcdn.com/images/woonyumnyum/post/1d131525-7a6a-4b82-8b77-387ec2f4e0ac/image.png)
출력해보면 이와 같이 A와 B가 순서대로 출력되는 것을 볼 수 있다.
이게 가능한 이유는, Sub 함수가 코루틴(suspend) 함수이기 때문에 A를 만나면 실행함과 동시에 잠시 Sub 함수를 빠져나간다. 그러다가 A가 자신의 일을 끝마치면 다시 Sub 함수로 돌아올 수 있기 때문이다. B 함수는 A 함수가 끝나야만 실행된다. 이게 코루틴으로 비동기 처리를 할 때 생기는 장점이다.

<br/>

---

> 출처

- https://whyprogrammer.tistory.com/m/596
- https://leveloper.tistory.com/m/209
- https://eunoia3jy.tistory.com/m/132
- https://cliearl.github.io/posts/android/coroutine-principle/
- https://wooooooak.github.io/kotlin/2019/08/25/%EC%BD%94%ED%8B%80%EB%A6%B0-%EC%BD%94%EB%A3%A8%ED%8B%B4-%EA%B0%9C%EB%85%90-%EC%9D%B5%ED%9E%88%EA%B8%B0/ (진짜 정리 잘되어있는 블로그)
