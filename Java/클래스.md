## 소스파일과 클래스의 관계

1. 자바에서는 하나의 소스파일(.java 확장자 파일) 안에는 public 클래스가 하나만 있어야 하고, 이때 소스파일의 이름은 public 클래스의 이름과 일치해야 한다.
2. 소스파일 이름과 main 함수가 들어있는 public 클래스의 이름이 같아야 컴퓨터가 찾아서 실행할 수 있다. (컴퓨터는 제일 먼저 main 함수를 실행함)
3. 만약 소스파일 안에 public 클래스가 없다면, 소스 파일 안에 포함된 어떤 클래스의 이름으로 하여도 상관없다.

## 클래스란?

### 같은 종류의 객체는 하나만 있을까?

자동차를 예로 들어보면, 영희네도 철수네도 같은 브랜드의 자동차를 가질 수 있다. 엔지니어가 설계하여 자동차 설계도를 만들고 이 설계도에 의하여 각각의 자동차가 만들어진다.
<br/>

객체 지향 소프트웨어에서도 객체들이 동일한 방법으로 생성된다.
객체에 대한 설계도를 `클래스`라고 한다. 클래스로부터 만들어지는 각각의 객체를 그 `클래스의 인스턴스`라고 한다.

### 왜 클래스를 통하여 객체를 생성하는 것일까?

일반적으로 프로그램에서는 같은 종류의 객체가 많이 필요하기 때문이다. <br/>예를 들어서 슈팅 게임 프로그램에서는 미사일을 나타내는 객체는 아주 많이 필요하기 때문에 미사일 클래스를 하나 만들어두고 필요할 때마다 객체를 찍어내는 것이 편리하다.
<br/>

객체지향에서는 소프트웨어의 기본 단위가 클래스가 된다. 소프트웨어를 만들어간다는 것은 클래스를 하나씩 추가해나가는 과정이다.
<br/>

## 클래스 구조

### 잘 설계된 클래스는 오직 하나의 논리적인 개념만을 정의해야 한다.

이제까지 우리가 사용해온 클래스는 main() 메소드만을 가지고 있었다. 일반적인 클래스라면 main()함수를 반드시 가질 필요가 없다. 특정한 클래스가 프로그램의 시작점이 되는 경우에만 클래스 안에 main() 메소드가 필요하다.
<br/>

예를들어 Television 클래스는 텔레비젼에 관련된 속성과 동작을 묶은 것이다. 텔레비전의 수많은 속성 중에서 채널번호, 볼륨, 전원상태만을 기술하기로 하자. 이렇게 불필요한 속성을 제거하는 과정을 추상화라고 한다.
<br/>

## 클래스 정의

컴파일러 입장에서 보면 이렇게 새로운 클래스를 정의하는 것은 프로그램에서 사용할 수 있는 새로운 자료형을 하나 추가하는 것과 같다. 클래스 정의는 단순히 객체를 찍어내기 위한 틀을 생성한 것이다. 아직 실제 객체는 생성되지 않았다.

## 객체 생성

Television 클래스의 객체를 생성하는 코드는 어디에 작성해야될까?
<br/>

자바에서는 클래스의 외부에 문장을 입력할 수 없다.
<br/>모든 문장은 반드시 어떤 클래스 안에 들어가야 한다. 따라서 우리는 Television 클래스를 테스트하기 위하여 별도의 클래스인 TelevisionTest 클래스를 생성한다. 이 클래스는 Television 클래스를 테스트하는 목적으로 생성되는 클래스이다. TelevisionTest 클래스에는 main() 메소드가 작성되고 여기서 Television 클래스 객체를 생성한다. TelevisionTest 클래스는 사물을 모델링하기 위하여 작성된 클래스가 아니라는 점에 유의한다.

## 객체 멤버 접근하기

최근에는 필드라는 이름 대신에 인스턴스 변수라는 용어도 많이 사용된다. 각 인스턴스(객체)가 자체적으로 가지고 있는 변수라는 의미이다.
<br/>

객체지향의 개념에서 보면 필드를 외부에서 접근하는 것은 바람직하지 않다. 객체 내의 필드는 메소드를 통해서 접근하는 것이 바람직하다.

## 참조 변수와 대입 연산

참조 변수에는 참조값(주소값)이 저장되어 있기 때문에 참조 변수를 복사하면 참고값이 복사되어서 동일한 객체를 참조하게 된다.

```java
Television tv1 = new Television();
Television tv2 = tv1;
```

tv1과 tv2는 서로 다른 객체를 참조하는 거 같지만 실제로는 동일한 객체를 참조하게 된다. tv1에 저장된 참조값이 tv2로 복사된다.
예를 들어서 다음과 같은 문장을 실행한다고 하면

```java
tv1.channel = 11;
System.out.println(tv1.channel);
System.out.println(tv2.channel);
```

화면에는 동일한 값인 11이 출력된다.

## 쓰레기 수집기

자바에서 객체들은 new 연산자에 의해 히프 메모리에 할당된다. 히프 메모리는 컴퓨터에서 사용 가능한 메모리를 모아 놓은 곳이다. 메모리는 무한하지 않기 때문에 이들 히프 메모리는 언제든지 고갈될 수 있다. 따라서 자바 시스템에서 사용되지 않는 객체들을 삭제하여 메모리를 확보하는 것이 필요하다.
<br/>

다른 언어에서는 프로그래머가 직접 객체의 삭제를 책임져야 하지만 자바에서는 자동 메모리 수거 시스템을 사용하는데 이것을 쓰레기 수집이라고 한다. 자바의 쓰레기 수집은 자동으로 이루어진다. 만약 객체에 대한 참조가 전혀 없다면 객체는 사용 자체가 불가능하기 때문에 이 객체는 없애도 되는것으로 간주하여 자바가 자동으로 삭제한다.

```java
Television myTV = new Television();
myTV = null

```

## 인수와 매개변수

참조 변수에 null이 대입되었기 때문에 생성된 객체를 가리키는 참조 변수는 하나도 남아있지 않다. 이런 경우에는 자바의 쓰레기 수집기가 메모리에서 객체를 제거한다.

메소드를 호출하는 곳에서 메소드 호출시 전달하는 값을 인수라고 하고 메소드에서 값을 받을 때 사용하는 변수를 매개변수라고 한다.

## 메소드 이름짓기

자바에는 예전부터 내려온 약속이 있다.

## String 클래스의 메소드

- equals() : 2개의 문자열이 일치하는지를 검사할때 유용
- matches() : 문자열이 어떤 문자열을 포함하고 있는지를 검사할 때 사용한다. 특히 정규식을 사용하여서 어떤 규칙을 적용할 수 있다.

  - 정규식에서 사용되는 메타문자의 의미를 요약하면 다음과 같다.
    ^ : 문자열의 시작을 표시<br/>
    $ : 문자열의 끝을 표시 <br/>
    . : 한개의 문자와 일치 <br/>
    \d : 한 개의 숫자와 일치 <br/>
    \w : 한 개의 문자나 숫자와 일치 <br/>
    \s : 공백, 탭, 줄바꿈, 캐리지리턴 문자와 일치 <br/>
    [] : [abc]는 a또는 b또는 c를 나타낸다. [a-z]는 a부터 z까지 중의 하나, [1-9]는 1부터 9까지 중의 하나를 나타낸다. <br/>

    문자열이 처음에 "www."로 시작하는지 검사하려면 다음과 같은 정규식을 사용하면 된다.
    str.matches("^www\\.(.+)")

## 접근자와 설정자

객체 지향 방법의 개념 중에 정보 은닉이 있었다. 정보 은닉이란 구현의 세부 사항을 클래스 안에 감추는 것이다. 대표적인 것이 클래스 안의 데이터를 외부에서 마음대로 변경하지 못하게 하는 것이다. 따라서 클래스 안에 변수를 선언할 때는 private을 붙이고, 메소드들은 외부에서 사용하도록 허용하는 것이 좋다.

## 접근자와 설정자의 사용 이유

1. 접근자와 설정자를 사용해야만 나중에 클래스를 업그레이드할 때 편하다.
2. 접근자에서 매개 변수를 통하여 잘못된 값이 넘어오는 경우, 이를 사전에 차단할 수 있다.
3. 필요할 때마다 필드값을 계산하여 반환할 수 있다.
4. 접근자만을 제공하면 자동적으로 읽기만 가능한 필드를 만들 수 있다.

`첫 번째 이유가 가장 중요`한데, 예를 들어서 Account 클래스의 경우 클래스의 멤버를 외부에서 마음대로 사용하고 있다면 은행에서 통장의 구조를 변경하기 아주 어려울 것이다. 예를 들어, 주민등록번호를 나타내는 필드인 regNumber를 외부에서 마음대로 사용하고 있었다면 주민등록번호 대신 아이핀을 사용하도록 변경하는 것이 불가능할 것이다. 하지만 만약 설정자나 접근자를 통하여 사용하고 있었다면 개발자는 안심하고 regNumber 변수를 iPin 변수로 변경할 수 있다.
