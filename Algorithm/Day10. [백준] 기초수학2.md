# 알고리즘 공부 10일차

### 백준 문제 :

1978, 2581, 11653, 1929(시간초과)

---

# 주요 문제 정리

## 2581. 소수

<br/>

> ### [문제](https://www.acmicpc.net/problem/2581)

#### <br/>자연수 M과 N이 주어질 때 M이상 N이하의 자연수 중 소수인 것을 모두 골라 이들 소수의 합과 최솟값을 찾는 프로그램을 작성하시오.<br/>예를 들어 M=60, N=100인 경우 60이상 100이하의 자연수 중 소수는 61, 67, 71, 73, 79, 83, 89, 97 총 8개가 있으므로, 이들 소수의 합은 620이고, 최솟값은 61이 된다.

<br/>

> ### Python3 코드

```python
import sys
m = int(sys.stdin.readline())
n = int(sys.stdin.readline())
prime_list = []
for i in range(m, n+1):
    if i == 0 or i == 1:
        continue
    for j in range(2, i):
        if i % j == 0:
            break
    else:
        prime_list.append(i)
if len(prime_list) <= 0:
    print(-1)
else :
    print(sum(prime_list), prime_list[0], sep='\n')
```

<br/>

> ### Python3 코드 풀이

### 1. 문제 요약

이 문제는 자연수 m과 n을 입력받아, m과 n사이의 모든 소수의 합과, 그 중 최소값을 구하는 문제이다.

<br/>
우선 자연수 0과 1은 소수가 아니므로 제외하고 문제를 풀었다. 그리고 m부터 n까지 for문을 돌면서 해당 숫자가 소수인지 아닌지 1과 자기자신을 제외한 모든 수로 하나하나 나눠본 후 소수라면 리스트변수에 추가하는 식으로 풀었다.

### 2. 소수를 구해준다.

```python
for i in range(m, n+1):
    if i == 0 or i == 1:
        continue
    for j in range(2, i):
        if i % j == 0:
            break
    else:
        prime_list.append(i)
```

상위 for문은 m부터 n까지 사이의 숫자인 i를 생성해준다.
하위 for문은 i를 나눠줄 숫자로, 1과 자신을 제외한 숫자들인 j를 생성해준다.

<br/> i가 j로 나눠진다면 소수가 아니므로 더 이상 검사하지 않고 다음 숫자로 넘어간다. 하위 for문을 모두 돌때까지 나눠지는 수가 없다면 소수이므로 prime_list 에 추가해준다.

### 3. 답을 출력해준다.

```python
if len(prime_list) <= 0:
    print(-1)
else :
    print(sum(prime_list), prime_list[0], sep='\n')
```

소수가 하나도 없다면 문제에서 요구한 대로 -1을 출력해준다.
소수가 있다면 소수들의 합과, 최솟값을 줄을 바꿔 출력해준다.

---

## [시간초과] 1929. 소수 구하기

<br/>

> ### [문제](https://www.acmicpc.net/problem/1929)

#### <br/>M이상 N이하의 소수를 모두 출력하는 프로그램을 작성하시오. 첫째 줄에 자연수 M과 N이 빈 칸을 사이에 두고 주어진다. (1 ≤ M ≤ N ≤ 1,000,000) M이상 N이하의 소수가 하나 이상 있는 입력만 주어진다. 한 줄에 하나씩, 증가하는 순서대로 소수를 출력한다.

<br/>

> ### Python3 코드

```python
m, n = map(int, input().split())
for i in range(m, n+1):
    if i > 1:
        for j in range(2, int(i**0.5)+1):
            if i % j == 0:
                break
        else:
            print(i)
```

<br/>

> ### Python3 코드 풀이

### 1. 문제 요약

이 문제는 m과 n사이의 소수를 출력하는 문제이다.

<br/>
처음에는 단순히 숫자를 2 ~ n 로 일일이 나누어서 검사하고 리스트에 넣어주는 식으로 풀었는데 시간 초과가 났다.
그래서 다른 블로그를 참고했는데 n까지 검사하는 것이 아니라 n의 제곱근까지만 검사해주면 소수인지 아닌지 판별이 나기 때문에 시간 초과 없이 문제를 해결할 수 있다.

### 2. 소수를 구해준다.

```python
for i in range(m, n+1):
    if i > 1:
        for j in range(2, int(i**0.5)+1):
            if i % j == 0:
                break
        else:
            print(i)
```

상위 for문은 m부터 n까지 사이의 숫자인 i를 생성해준다.
하위 for문은 i를 나눠줄 숫자로, 모든 수의 약수는 무조건 제곱근 범위에 존재하기 때문에 i의 제곱근까지만 검사해준다.

<br/> 하위 for문을 모두 돌때까지 나눠지는 수가 없다면 소수이므로 출력해준다.

### 3. 소수 판별법

보통 n이 소수인지 판별하기 위해서 n이 2~n-1 까지의 어떤 수로도 나눠지지 않는지 for문을 돌며 검사를 한다.
이 방법을 사용하면 한 숫자에 대해 n번의 검사를 하기 때문에(O(n)의 복잡도) n개의 수의 소수 판단을 하는 것은 O(n^2)의 시간 복잡도를 갖는다. 따라서 숫자가 커지면 너무 많은 시간이 걸린다.

그래서 이 방법 대신 `제곱근`을 활용한 방법이 있다.
<br/>n의 약수는 무조건 sqrt(n)의 범위에 존재한다.<br/>
만약 n이 12이라면 12의 약수는 1, 2, 3, 4, 6, 12 이다. 여기서 1과 12를 제거하면 2 \* 6, 3 \* 4, 4 \* 3, 6 \* 2의 형태이다. 이들 중 절반 이후부터는 앞에 나왔던 수식의 몫과 나누는 값이 역전된 모습인 것을 알 수 있다. 몫이 커지면 나누는 값이 작아지고, 몫이 작아지면 나누는 값이 커지는 반비례 관게인 것이다. 따라서 n의 제곱근 범위까지만 나누어봐도 소수인지 아닌지 판별을 할 수 있다.
