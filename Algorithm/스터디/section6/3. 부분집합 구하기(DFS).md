<내 코드> - 포기

```python
import sys
sys.stdin = open("input.txt", "r")
def DFS(x):
    if x > 0:
        DFS(x-1)
        print(x, end=' ')

if __name__ == "__main__":
    n = int(input())
    DFS(n)
```

<강의 코드>
(공집합 포함)

```python
import sys
#sys.stdin = open("input.txt", "r")
def DFS(v):
    if v == n+1:
        for i in range(1, n+1):
            if ch[i] == 1:
                print(i, end=' ')
        print()
    else:
        ch[v] = 1
        DFS(v+1)
        ch[v] = 0
        DFS(v+1)

if __name__ == "__main__":
    n = int(input())
    ch = [0] * (n+1)
    DFS(1)
```

만약 집합{1,2,3}의 부분집합을 구할때에는 1이 존재/존재x , 2가 존재/존재x, 3이 존재/존재x = 2\*2\*2 = 8개의 부분집합이 존재한다.

DFS 함수의 매개변수가 부분집합을 만드는 원소라고 생각하자.
만약 DFS(1)이면 1이 루트 노드에 있고, 왼쪽 노드는 1이 포함되는 경우, 오른쪽 노드는 1이 포함되지 않는 경우로 트리를 구성하면 된다.
이렇게 구성한 트리는 아래 그림과 같다.
![](https://velog.velcdn.com/images/woonyumnyum/post/19dfd25e-70ab-46b0-9032-89e6e841a02c/image.jpg)
D(1)의 왼쪽 오른쪽 노드는 D(2)가 자리하고, 왼쪽 노드는 2가 포함되는 경우, 오른쪽 노드는 2가 포함되지 않는 경우로 생각해야된다. D(2)의 자식노드로는 2를 사용한다 안한다 두가지로 뽑아나가야된다. 그렇게 계속 뻗어나가다가 D(4)에 도달하면 종착점이므로 이제 부분집합을 출력하면 된다.
이렇게 뻗어나가는 트리를 `상태트리`라고 한다.
앞으로 DFS 문제를 잘 풀려면 상태트리를 잘 구성하고 재귀함수를 호출하면 된다.
