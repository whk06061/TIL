# 내 힘으로 풀었다.. 넘 뿌듯

import sys
from collections import deque

sys.stdin = open("input.txt", "r")
n = int(input())
k = int(input())
# 보드 0으로 초기화 (0행~n-1행)
board = [[0] * (n) for _ in range(n)]

# 사과 있는 부분 1 채우기
for _ in range(k):
    r, c = map(int, input().split())
    board[r - 1][c - 1] = 1

# 이동 정보 받기
order = deque()
l = int(input())
for _ in range(l):
    second, direction = input().split()
    order.append((second, direction))

# 북, 동, 남, 서 방향 정의
dx = [-1, 0, 1, 0]
dy = [0, 1, 0, -1]
# 현재 뱀은 동쪽을 바라 보고 있는 상황
direction = 1


def rotation_left():
    global direction
    direction -= 1
    if direction == -1:
        direction = 3


def rotation_right():
    global direction
    direction += 1
    if direction == 4:
        direction = 0


# 뱀 위치 저장 (0번 인덱스가 머리)
snake = deque([(0, 0)])

# 시뮬레이션 시작
count = 0
while True:
    print(snake)
    count += 1
    nx = snake[0][0] + dx[direction]
    ny = snake[0][1] + dy[direction]
    # 다음 칸이 벽 이거나 자신의 몸과 닿을 때
    if nx < 0 or ny < 0 or nx >= n or ny >= n or ((nx, ny) in snake):
        print(count)
        sys.exit(0)
    # 다음 칸에 사과 있을 때
    if board[nx][ny] == 1:
        snake.appendleft((nx, ny))
        board[nx][ny] = 0
        continue
    # 다음 칸에 사과 없을 때
    if board[nx][ny] == 0:
        if len(snake) == 1:
            snake[0] = (nx, ny)
        if len(snake) > 1:
            # 한 칸씩 앞으로 이동
            previous = snake[0]
            for i in range(1, len(snake)):
                current = snake[i]
                snake[i] = previous
                previous = current
            # 머리 위치 재설정
            snake[0] = (nx, ny)
    if order:
        if str(count) == order[0][0]:
            if order[0][1] == "L":
                rotation_left()
            if order[0][1] == "D":
                rotation_right()
            order.popleft()
