### 문제

A, B 두 사람은 서로 무게가 다른 볼링공을 고르려고 합니다.
볼링공은 총 N개가 있으며 각 볼링공마다 무게가 적혀 있고, 공의 번호는 1번부터 순서대로 부여됩니다.
같은 무게의 공이 여러 개 있을 수 있지만, 서로 다른 공으로 간주합니다. 볼링공의 무게는 1부터 M까지의 자연수 형태로 존재합니다. N개의 공의 무게가 각각 주어질 때, 두 사람이 볼링공을 고르는 경우의 수를 구하는 프로그램을 작성하세요.

### 문제 풀이

이 문제를 효과적으로 해결하기 위해서는, 무게마다 볼링공이 몇 개 있는지를 계산해야 한다.
문제에서 등장했던 예시를 기준으로 보면

- 무게가 1인 볼링공: 1개
- 무게가 2인 볼링공: 2개
- 무게가 3인 볼링공: 2개

- A가 무게가 1인 공을 선택할 때의 경우의 수는
  - 1(무게가 1인 공의 개수) X 4(B가 선택하는 경우의 수) = 4가지 이다.
- A가 무게가 2인 공을 선택할 때의 경우의 수는
  - 2(무게가 2인 공의 개수) X 2(B가 선택하는 경우의 수) = 4가지 이다.
- A가 무게가 3인 공을 선택할 때의 경우의 수는
  - 2(무게가 2인 공의 개수) X 0(B가 선택하는 경우의 수) = 0가지 이다.

#### 답안

```python
n, m = map(int, input().split())
data = list(map(int, input().split()))

#1부터 10까지의 무게를 담을 수 있는 리스트
array = [0] * 11

# 각 무게에 해당하는 볼리공 개수 카운트
for x in data:
    array[x] += 1

result = 0
#1부터 m까지의 각 무게에 대하여 처리
for i in range(1, m+1):
    n -= array[i]   #무게가 i인 볼링공의 개수(A가 선택할 수 있는 개수)제외
    result += array[i] * n  #B가 선택하는 경우의 수와 곱하기

print(result)


```

#### 입출력 조건

<입력>
5 3
1 3 2 3 2

<출력>
8

### 내 풀이

볼링공 무게대로 내림차순으로 정렬한다음 이중 for문을 돌면서 자신보다 작은 수와의 조합을 구해준다.
내림차순으로 정렬되어있기 때문에 자신보다 큰 수는 이미 선택하고 넘어왔기 때문이다.
이중 for문보다 효율적인 코드가 있을지 고민을 더 해보는게 좋겠다.

#### 내 코드

```python
import sys
sys.stdin = open("input.txt", "r")
n, m = map(int, input().split())
a = list(map(int, input().split()))
a.sort(reverse=True)
count = 0
for i in range(0, len(a)):
    target = a[i]
    for j in range(i+1, len(a)):
        if target > a[j]:
            count += 1

print(count)
```
